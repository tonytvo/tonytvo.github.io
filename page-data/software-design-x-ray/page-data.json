{"componentChunkName":"component---src-templates-blog-post-js","path":"/software-design-x-ray/","result":{"data":{"site":{"siteMetadata":{"title":"Conversations on agile technical practices and investments","disqus":{"shortName":"trungvo"}}},"markdownRemark":{"id":"5cf73778-a9d8-5686-886b-7c432a54e424","excerpt":"key-takeaways Use statistics and data science to uncover both problematic code and the behavioral patterns of the developers who build your software. This…","html":"<h1 id=\"key-takeaways\" style=\"position:relative;\"><a href=\"#key-takeaways\" aria-label=\"key takeaways permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>key-takeaways</h1>\n<ul>\n<li>\n<p>Use statistics and data science to uncover both problematic code and the behavioral patterns of the developers who build your software. This combination gives you insights you can’t get from the code alone. Use these insights to prioritize refactoring needs, measure their effect, find implicit dependencies between different modules, and automatically create knowledge maps of your system based on actual code contributions.</p>\n</li>\n<li>\n<p><img src=\"/8cba2f072a3c55994143b0303c780349/Software-Design-X-Rays-info-graphics.pdf\" alt=\"software design x ray\"></p>\n</li>\n</ul>\n<h1 id=\"prioritize-and-react-to-technical-debt\" style=\"position:relative;\"><a href=\"#prioritize-and-react-to-technical-debt\" aria-label=\"prioritize and react to technical debt permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Prioritize and React to Technical Debt</h1>\n<ul>\n<li><strong>Why Technical Debt Isn’t Technical?</strong></li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Technical debt is a metaphor that lets developers explain the need for refactorings and communicate technical trade-offs to business people.</code></pre></div>\n<ul>\n<li>\n<p>Technical-debt decisions apply both at the</p>\n<ul>\n<li>Micro level where we may choose to hack in a new feature with the use of complex conditional logic</li>\n<li>Macro level when we make architectural trade-offs to get the system through yet another release</li>\n</ul>\n</li>\n<li>\n<p>Technical debt is a strategic business decision rather than a technical one</p>\n</li>\n</ul>\n<blockquote>\n<ul>\n<li><strong>Keep a decision log</strong> :\n<ul>\n<li>Human memory is fragile</li>\n<li>Cognitive biases are real</li>\n<li>A project decision log will be a tremendous help in keeping track of your rationale for accepting technical debt</li>\n<li>Jotting down decisions on a wiki or shared document helps you maintain knowledge over time.</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<ul>\n<li>\n<p>Technical debt is  frequently misused to describe legacy code</p>\n<ul>\n<li>In fact, the two terms are often used interchangeably to describe code that</li>\n</ul>\n</li>\n<li>\n<p><strong>Interest Rate Is a Function of Time</strong></p>\n</li>\n</ul>\n<blockquote>\n<ul>\n<li>Just because some code is bad doesn’t mean it’s technical debt. It’s not technical debt unless we have to pay interest on it, and interest rate is a function of time.</li>\n</ul>\n</blockquote>\n<ul>\n<li>\n<p>We would need a time dimension on top of our code to reason about interest rate</p>\n</li>\n<li>\n<p><strong>Your Mental Models of Code</strong></p>\n<ul>\n<li>As programmers we need to serve two audiences :\n<ul>\n<li>Machine that executes our programs :\n<ul>\n<li>Doesn’t care much about style</li>\n<li>Is annoyingly pedantic about content and pretty bad at filling in the gaps</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Programmers maintaining our code :\n<ul>\n<li>Has much more elaborate mental processes</li>\n<li>Needs our guidance to use those processes efficiently</li>\n</ul>\n</li>\n<li>As we learn a topic we build mental representations of that domain : schemas\n<ul>\n<li><strong>A schema</strong> : theoretical construct used to describe the way we organize knowledge in our memory and how we use that knowledge for a particular event.</li>\n</ul>\n</li>\n<li>Understanding code also builds on schemas :\n<ul>\n<li>General schemas for syntactic and semantic knowledge</li>\n<li>Like knowing the construction order of a class hierarchy in C++</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p><em>Building expertise means evolving better and more efficient mental models.</em></p>\n</blockquote>\n<ul>\n<li>\n<p><strong>Quality Suffers with Parallel Development</strong></p>\n<ul>\n<li>\n<p>Practices like peer reviews and coding standards help you mitigate the problems with parallel development by catching misunderstandings and enforcing a degree of consistency.</p>\n<ul>\n<li>The structure of the development organization is a stronger predictor of defects than any code metrics.</li>\n<li><strong>The risk that a specific commit introduces a defect increases with the number of developers who have previously worked on the modified code.</strong></li>\n</ul>\n</li>\n<li>\n<p><strong>Mine Your Organization’s Collective Intelligence</strong></p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>How do we uncover the areas in need of improvement?</strong></p>\n<ul>\n<li>Where’s the code with the highest interest rate?</li>\n<li>Does our architecture support the way our system evolves?</li>\n<li>Are there any productivity bottlenecks for interteam coordination?</li>\n</ul>\n</li>\n<li>\n<p><strong>Identify Code with High Interest Rates</strong></p>\n<ul>\n<li><strong>Measure Interest Rates</strong></li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<ul>\n<li>Refactoring complex code is a high-risk and expensive activity, so you want to ensure your time is well invested</li>\n</ul>\n</blockquote>\n<ul>\n<li>\n<p>Sometimes most development activity is focused on a relatively small part of the codebase</p>\n</li>\n<li>\n<p><strong>Change Frequency = a proxy for Interest Rate</strong></p>\n</li>\n<li>\n<p><em>Prioritize Technical Debt with Hotspots</em></p>\n<ul>\n<li>A hotspot is complicated code that you have to work with often.</li>\n<li>Hotspots are calculated by combining the two metrics we’ve explored:\n<ul>\n<li>Calculating the change frequency of each file as a proxy for interest rate</li>\n<li>Using the lines of code as a simple measure of code complexity</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Use Hotspots to Improve, Not Judge</strong></p>\n</li>\n</ul>\n<blockquote>\n<ul>\n<li>It’s easy to critique code in retrospect.\n<ul>\n<li>Remember that we don’t know the original context in which the code was developed</li>\n<li>Code is often written under strong pressures of time constraints and changing requirements.</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<ul>\n<li>\n<p><strong>Evaluate Hotspots with Complexity Trends</strong></p>\n<ul>\n<li>We can find out how severe a potential problem is via a complexity trend analysis, which looks at the accumulated complexity of the file over time.</li>\n<li>The trend is calculated by fetching each historic version of a hotspot and calculating the code complexity of each historic revision.</li>\n</ul>\n</li>\n<li>\n<p><strong>What Is Complexity, Anyway?</strong></p>\n<ul>\n<li>\n<p>Get more insights if the trend is capable of differentiating between</p>\n<ul>\n<li>Growth in pure size</li>\n<li>Versus growth in complexity</li>\n</ul>\n</li>\n<li>\n<p>The <strong>indentation-based complexity</strong> metric provides one such approach</p>\n<ul>\n<li>Simple metric that has the advantage of being <strong>language neutral</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Use X-Rays to Get Deep Insights into Code</strong></p>\n<ul>\n<li>X-Ray gives you a prioritized list of the methods to inspect and, possibly, refactor :</li>\n</ul>\n</li>\n<li>\n<p><strong>Coupling in Time: A Heuristic for the Concept of Surprise</strong></p>\n</li>\n</ul>\n<blockquote>\n<ul>\n<li>Change coupling can helps us design better software as we uncover expensive change patterns in our code</li>\n</ul>\n</blockquote>\n<ul>\n<li>**Uncover Expensive Change Patterns</li>\n</ul>\n<p>How do we know if a software design is any good?**</p>\n<ul>\n<li>\n<p>Most answers concern facets of programming such as the importance of naming, testability, and cohesion</p>\n</li>\n<li>\n<p>We’ll go beyond that and assert that none of those qualities matter unless our software design supports the kind of changes we need to make to the code</p>\n</li>\n<li>\n<p><strong>Code under active development is a moving target</strong></p>\n</li>\n<li>\n<p><strong>What Is Change Coupling?</strong></p>\n<ul>\n<li>Change coupling is different from how we programmers typically talk about coupling.</li>\n<li>Change coupling is invisible in the code itself</li>\n<li>We mine it from our code’s history and evolution</li>\n<li>Change coupling means that two (or more) files change together over time</li>\n<li>First coupling criterion : when files are changed within the same commit</li>\n</ul>\n</li>\n</ul>\n<p>​</p>\n<blockquote>\n<ul>\n<li>Change Coupling Both Is and Isn’t Temporal Coupling</li>\n</ul>\n</blockquote>\n<ul>\n<li>Look for surprising patterns when investigating change coupling</li>\n<li><strong>Change coupling itself is neither good nor bad; it all depends on context</strong>\n<ul>\n<li>A unit test that changes together with the code under test is expected\n<ul>\n<li>Should be worried if not</li>\n<li>Indicate that our tests aren’t kept up to date</li>\n</ul>\n</li>\n<li>On the other hand, if two seemingly independent classes change together over time we might have discovered :\n<ul>\n<li>An erroneous abstraction</li>\n<li>Copy-pasted code</li>\n<li>or—as is often the case—both</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<ul>\n<li>Calculate Change Coupling from the Command Line by using <a href=\"https://github.com/adamtornhill/code-maat\">code-maat</a> ​</li>\n</ul>\n</blockquote>\n<ul>\n<li>\n<p><strong>Minimize Your Investigative Efforts</strong></p>\n<ul>\n<li>Change coupling analysis gives us information on how our code grows, which lets us detect implicit dependencies that point to code that’s hard to maintain.</li>\n<li>Some of the worst hotspots and design issues tend to be in automated tests\n<ul>\n<li>Often missing abstractions:\n<ul>\n<li>Test Data: We need to model the domain of our tests and express the concept of test data</li>\n<li>Assertions: We need a specialized assertion statement that encapsulates our test criteria</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>The Power of Language-Neutral Analyses</strong></p>\n<ul>\n<li>The power of language-neutral analyses is that we <strong>can spot relationships between files implemented in different languages</strong></li>\n<li>Today’s systems are often polyglot codebases</li>\n</ul>\n</li>\n<li>\n<p><strong>Pay Off Your Technical Debt</strong></p>\n<ul>\n<li>Refactoring code that’s under heavy development, perhaps even shared between multiple teams, adds another dimension to the problem.</li>\n<li><strong>Follow the Principle of Proximity</strong>\n<ul>\n<li>Proximity focuses on How well organized your code is with respect to Readability and change</li>\n<li>Proximity implies that <strong>functions that are changed together are moved closer together</strong>. Proximity is a design principle</li>\n<li>Proximity principle is a refactoring technique that uses feedback from how our code evolves :\n<ul>\n<li>By ordering our functions and methods according to our change patterns</li>\n<li><strong>We communicate information that isn’t expressible in programming-language syntax</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>Automate Proximity Recommendations</strong>\n<ul>\n<li>A proximity refactoring serves as a mental note that the two functions belong together.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Refactor Congested Code with the Splinter Pattern</strong></p>\n<ul>\n<li>Splinter pattern provides a structured way to break up hotspots into manageable pieces that can be divided among several developers to work on</li>\n</ul>\n</li>\n<li>\n<p><strong>Parallel Development Is at Conflict with Refactoring</strong></p>\n<ul>\n<li>Our refactoring goal conflicts with the short-term evolution of the overall system\n<ul>\n<li>Most organizations just cannot afford to pause ongoing work so that we can refactor in a safe, development-free vacuum</li>\n</ul>\n</li>\n<li>The splinter pattern resolves this dilemma by recognizing that refactoring a hotspot is an iterative process\n<ul>\n<li>In a splinter refactoring you\n<ul>\n<li>Won’t even improve the code quality as such</li>\n<li>BUT rather <strong>transform the code to a structure where multiple people can work together in parallel toward the overall refactoring goal.</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Split a Hotspot File Along Its Responsibilities</strong></p>\n</li>\n</ul>\n<blockquote>\n<p>The intent of the splinter pattern is to break a hotspot into smaller parts along its responsibilities while maintaining the original API for a transient period.</p>\n</blockquote>\n<ul>\n<li>\n<p>Keep the original method signatures and replace the method bodies with a simple delegation to the extracted modules.</p>\n</li>\n<li>\n<p>Steps behind an iterative splinter refactoring :</p>\n<ul>\n<li><em>Ensure your tests cover the splinter candidate:</em> have an adequate test suite</li>\n<li><em>Identify the behaviors inside your hotspot:</em>  look at the names of the methods inside the hotspot / identify code that forms groups of behaviors</li>\n<li><em>Refactor for proximity:</em> form groups of functions with related behavior inside the larger file, based on the behaviors you identified earlier</li>\n<li><em>Extract a new module</em> for the behavior with the most development activity : use X-Ray</li>\n<li><em>Delegate to the new module.</em> Replace the body of the original methods with delegations to your new module</li>\n<li><em>Perform the necessary regression tests to ensure you haven’t altered the behavior of the system</em></li>\n<li><em>Select the next behavior to refactor and start over at step 4</em></li>\n</ul>\n</li>\n<li>\n<p><strong>Consequences of Splinters</strong></p>\n<ul>\n<li>The hotspot now acts as a facade that maintains the original API</li>\n</ul>\n</li>\n<li>\n<p><strong>The Curse of a Successful System</strong></p>\n</li>\n</ul>\n<blockquote>\n<p><em>Much code decay isn’t due to incompetence but rather is owed to the success of an evolving product.</em></p>\n</blockquote>\n<ul>\n<li><strong>The Principles of Code Age</strong>\n<ul>\n<li>\n<p>Stabilize Code by Age :</p>\n<ul>\n<li>Organize our code by its age</li>\n<li>Turn stable packages into libraries</li>\n<li>Move and refactor code we fail to stabilize</li>\n</ul>\n</li>\n<li>\n<p><strong>Related advantages</strong></p>\n<ul>\n<li><em>Promotes long-term memory models of code:</em> Stable packages serve as chunks that remain valid over time, which means our expectations of a piece of code won’t be broken</li>\n<li><em>Lessens cognitive load since there’s less active code:</em> The more code you manage to stabilize, the less knowledge you need to keep in your head</li>\n<li><em>Prioritizes test suites to shorten lead times:</em> Identify which parts of the software you can safely skip test runs</li>\n</ul>\n</li>\n<li>\n<p><strong>3 generations of code</strong></p>\n<ul>\n<li>Dan North claims that we want our code to be either :\n<ul>\n<li>very recent</li>\n<li>Or old</li>\n<li>The kind of code that’s hard to understand lies in between these two extremes</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Ebbinghaus forgetting curve</strong></p>\n<ul>\n<li>To retain the information we need to repeat it, and with each repetition we’re able to improve our performance by remembering more.</li>\n<li>Each time we revisit mid-aged code we need to relearn its inner workings, which comes at a cost of both time and effort.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"work-with-large-codebases-and-organizations\" style=\"position:relative;\"><a href=\"#work-with-large-codebases-and-organizations\" aria-label=\"work with large codebases and organizations permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Work with Large Codebases and Organizations</h1>\n<ul>\n<li>\n<p>Work at an architectural level to gain insights into the system as a whole.</p>\n</li>\n<li>\n<p><strong>Spot Your System’s Tipping Point</strong></p>\n<ul>\n<li>Use social code analysis to make sense of large-scale systems by Breaking them down into subsystems</li>\n<li>Large systems become even more complex once we add the social dimension\n<ul>\n<li>As a project grows beyond 12 or 15 developers :\n<ul>\n<li><strong>Coordination, motivation and communication issues tend to cause a significant cost overhead.</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Know if a specific part of the code is a coordination bottleneck</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<ul>\n<li>The scale of a codebase has to be reflected in both the organization of people and the architecture of the system.</li>\n</ul>\n</blockquote>\n<ul>\n<li><strong>Divide and Conquer with Architectural Hotspots</strong>\n<ul>\n<li><em>Identify your architectural boundaries:</em>\n<ul>\n<li>Sometimes those boundaries are documented</li>\n<li>If not, you need to reverse-engineer those boundaries, and a good starting point is to <em><strong>base them on the folder structure of the codebase.</strong></em></li>\n</ul>\n</li>\n<li><em>Run a hotspot analysis on an architectural level:</em>\n<ul>\n<li>Identify the subsystems with the most development effort</li>\n<li>Visualize the complexity trend of a whole architectural component.</li>\n</ul>\n</li>\n<li><em>Analyze the files in each architectural hotspot:</em>\n<ul>\n<li>Focus on individual files</li>\n<li>Our analysis scope is smaller since we focus on one subsystem at a time</li>\n<li><a href=\"./hotspot-analysis.png\">hotspot analysis</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<ul>\n<li>Always remember that just because some code is a hotspot, that doesn’t necessarily mean it’s a problem.</li>\n</ul>\n</blockquote>\n<ul>\n<li>\n<p>A hotspot means</p>\n<ul>\n<li>We’ve identified a part of the code that requires our attention</li>\n<li>Since it attracts many changes</li>\n</ul>\n</li>\n<li>\n<p><strong>The more often something is changed</strong></p>\n<ul>\n<li>**The more important it is that the corresponding code is of **\n<ul>\n<li>High quality so</li>\n<li>all those changes are simple and low risk</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Analyze subsystems</strong></p>\n<ul>\n<li>Size alone may be problematic\n<ul>\n<li>Large files are likely to contain many different responsibilities and be hard to navigate</li>\n</ul>\n</li>\n<li>Complexity trends of the code</li>\n</ul>\n</li>\n<li>\n<p><strong>Prioritize Function Hotspots and Code Clones</strong></p>\n<ul>\n<li>Launch X-Ray on\n<ul>\n<li>Have a prioritized list of refactoring candidates</li>\n<li><a href=\"./refactor-candidates.png\">refactoring candidates</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<ul>\n<li>There are no hard rules, but with a heuristic you want to inspect the top 10 hotspots in your subsystem.</li>\n</ul>\n</blockquote>\n<ul>\n<li><strong>Fight the Normalization of Deviance</strong></li>\n</ul>\n<p>Each time you accept a risk, the deviations become the new normal. (see Challenger Launch study by sociologist Diane Vaughan)\nWe have plenty of normalization of deviance in software development :\nInherit a file with 15,000 lines of code\nFirst : shocked by the amount of code and the lack of higher-level organization.\nBut if you work with that code long enough\nThose 15,000 lines become the new normal\nBesides, what difference does a few more lines of code make?\nGet a Whistleblower\nComplexity trends serve as excellent whistleblowers by giving us an unbiased frame of reference that helps us detect when we accept a quality ditch too much\nDecide upon a sample interval—for example, once per month.\nCalculate a complexity trend for each file in the logical component\nAggregate the individual trends into a single trend\nCommunicate with Nontechnical Managers - Data buys trust\nStart by calculating the percentage of commits that involve your top hotspots\n10 to 15 percent is common\nTo show your managers how important that code is for your ability to support new features and innovations\nFollow up with the corresponding complexity trends to explain that the code gets worse over time, which will slow you down\nAdd the people side to your presentation to highlight that the hotspots are coordination bottlenecks too.\nLater you can visualize the effects of a refactoring with a steep downward trend of your prioritized hotspot.\nBeyond Conway’s Law\nInterteam communication is an inevitable aspect of building large systems, and thus ease of communication should be a key nonfunctional requirement of any architecture :\nDevelopment productivity increases with better socio-technical congruence\nExcess coordination needs correlate directly to increased lead times\nThe number of authors behind each component provides a shallow indication of coordination needs, and is just a starting point.\nRank Code by Diffusion\nRanks all the modules in our codebase based on how diffused the development effort is\nThen use that as a proxy for coordination needs\nThis is a quantitative metric that we get through a fractal value analysis\nA fractal value is an algorithm that delivers a normalized value between 0.0 and 1.0 based on how many different authors have contributed and how the work is distributed among them.\n0 : Single author\n1 : the more contributors there are\nReact to Developer Fragmentation\nThere is a strong correlation between the fractal value of a module and the number of reported bugs.\nUse the fractal values to :\nPrioritize code reviews : Code reviews done right are a proven defect-removal\nFocus tests : Identify the areas of the code where you need to focus extra tests\nReplan suggested features :\nBefore you start on a new feature, measure the development fragmentation over the past weeks.\nIf your planned work involves an area of the code with high developer congestion\nReplan and delay the start on any new feature implementation.\nRedesign for increased parallelism : identify candidates for splinter refactorings allowing people to work more independently.\nIntroduce areas of responsibility : reassess the current ways of working, perhaps by introducing teams that are aligned with the structure of the codebase\nCode Ownership and Diffusion of Responsibility\nPsychological phenomenon called diffusion of responsibility :\nIn larger groups we don’t feel a personal sense of responsibility\nWe assume someone else should react and help.\nCode Ownership Means Responsibility\nOwnership is a mechanism to counter the diffusion of responsibility\nIt suggests that someone takes personal responsibility for the quality and future of a piece of code\nProvide Broad Knowledge Boundaries\nSeveral techniques for it :\nInvite people from other teams to code reviews\nSchedule recurring sessions where you present walkthroughs of a solution or design\nEncourage people to rotate teams\nThe key to finding the right boundaries is to make it a deliberate rather than an accidental designation.\nMotivation Losses in Teams\nSocial loafing is a type of motivation loss that may occur when we feel that the success of our team depends little on our actual effort.\nWe pretend to do our part of the work, when in reality we just try to look busy and hope our peers keep up the effort.\nSeveral factors can minimize the risk of social loafing:\nSmall groups\nEvaluation : Code reviews done right have positive motivational effects the reviews show that someone else cares about your contribution\nLeadership by example : need to model the behaviors you want to see in others\nVisibility: Recognize each person’s contributions by presenting knowledge maps that show the main contributors behind each module\nGuide On- and Off-boarding with Social Data\nIdentify the Experts\nOne of the challenges of communication is to find out who to communicate with, and this general problem gets harder with geographical distance.\nThe knowledge map represents the main developer behind each file with a unique color.\nMeasure Upcoming Knowledge Loss\nThis analysis uses the same data as the knowledge maps; the only difference is that we form two virtual teams:\nOne for people who actively work on the codebase\nOne for people who are about to leave\nReact to Knowledge Loss\nWhen a developer resigns and has a notice period to work out, run this analysis to identify the parts of the system where your organization needs to focus to maintain knowledge.\nKnow the Biases and Workarounds for Behavioral Code Analysis\nNeed a minimum amount of data before you can start to see clear patterns in a behavioral code analysis\nIncorrect author info\nCopy-paste repositories: extract a component into a separate Git repository but fails to migrate its history\nMisused squash commits: Git lets you squash commits, effectively merging separate commits into one.\nUseful on a smaller scale for a single developer\nDisastrous when applied to work committed by several individuals.\nThe resulting history erases both\nSocial information\nChange coupling data.</p>\n<h1 id=\"quotes\" style=\"position:relative;\"><a href=\"#quotes\" aria-label=\"quotes permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Quotes</h1>\n<h1 id=\"references\" style=\"position:relative;\"><a href=\"#references\" aria-label=\"references permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>References</h1>\n<ul>\n<li><a href=\"https://kula.blog/posts/software_design_x-rays/\">https://kula.blog/posts/software_design_x-rays/</a></li>\n<li><a href=\"https://skarlso.github.io/2021/11/27/summary-of-programmers-brain/\">https://skarlso.github.io/2021/11/27/summary-of-programmers-brain/</a></li>\n<li><a href=\"https://understandlegacycode.com/blog/key-points-of-programmer-brain/\">https://understandlegacycode.com/blog/key-points-of-programmer-brain/</a></li>\n<li><a href=\"https://understandlegacycode.com/blog/key-points-of-software-design-x-rays/\">https://understandlegacycode.com/blog/key-points-of-software-design-x-rays/</a></li>\n<li><a href=\"https://yoan-thirion.gitbook.io/knowledge-base/software-craftsmanship/software-design-x-rays\">https://yoan-thirion.gitbook.io/knowledge-base/software-craftsmanship/software-design-x-rays</a></li>\n<li><a href=\"https://yoan-thirion.gitbook.io/knowledge-base/software-craftsmanship/the-programmers-brain\">https://yoan-thirion.gitbook.io/knowledge-base/software-craftsmanship/the-programmers-brain</a></li>\n</ul>","frontmatter":{"title":"software design x ray by Adam Tornhill summary wip","date":"February 19, 2023","description":"software design x-ray by Adam Tornhill summary"}},"previous":{"fields":{"slug":"/coffee-machine-pratice-notes-feb-18-2023/"},"frontmatter":{"title":"Notes on coffee machine kata practice Feb 18th 2023"}},"next":{"fields":{"slug":"/ikigai-the-japanese-secret-to-a-long-and-happy-life/"},"frontmatter":{"title":"Ikigai The Japanese Secret to a Long and Happy Life summary by Hector Garcia and Francesc Miralles"}}},"pageContext":{"id":"5cf73778-a9d8-5686-886b-7c432a54e424","previousPostId":"c58f21ec-46c5-5d39-b093-86f29087f807","nextPostId":"e8dce946-fb62-5517-bd87-33f315f55226"}},"staticQueryHashes":["2841359383","3257411868"],"slicesMap":{}}