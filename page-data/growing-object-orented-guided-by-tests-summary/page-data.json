{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/growing-object-orented-guided-by-tests-summary/",
    "result": {"data":{"site":{"siteMetadata":{"title":"Tony Vo Blog"}},"markdownRemark":{"id":"df65a369-42a7-51f0-80fa-ce1671f09e67","excerpt":"Key ideas practice TDD as a design technique and not as a testing technique Software development as a learning process. Expose uncertainly early by testing our…","html":"<h1>Key ideas</h1>\n<ul>\n<li>practice TDD as a design technique and not as a testing technique</li>\n<li><strong>Software development as a learning process.</strong>\n<ul>\n<li><strong>Expose uncertainly early by testing our assumption as early as possible</strong></li>\n</ul>\n</li>\n<li><strong>we use mock objects to identify the essential interactions between modules/objects. This leads to more effective abstractions, which reduces the cost of changing the cost safely over time.</strong></li>\n<li>Stub queries; expect actions???</li>\n<li><strong>Write code that depends as little as possible on its context.</strong></li>\n<li><strong>programming by intention</strong></li>\n</ul>\n<h1>Test-Driven Development (TDD) and Quality</h1>\n<ul>\n<li>Software development as a learning process.</li>\n<li>The best approach a team can take is to use empirical feedback to learn about the system and its use and then apply it back to the system.</li>\n<li>Development is incremental and iterative.\n<ul>\n<li>Incremental development builds a system feature by feature. Each feature is implemented as an end-to-end slice. As a result, the system is continuously integrated and ready for deployment.</li>\n</ul>\n</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/e772ae6d7ae6a4369beb1c330133321d/6af66/walking-skeleton-goos.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 41.139240506329116%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAIAAAB2/0i6AAAACXBIWXMAAAsTAAALEwEAmpwYAAABNUlEQVQY02XPS0vDQBAH8H7/u0dPFRVPfgcRQUEQH2n6srGWpq3ZZjeb3c3sPDSJVsRhDjN/+MHMYLlap5OZMS4Zz9LprLau1OZpNLaVE5J59jadLwjZGLvKc2ZBoHyzc94j0EDaAEXE+1CVGhoQkSxbbndFbHi7U0WhEJGZvfPeB4DGVh4ghhp+cVtE7doOyMQYqY8ZmZCYpLa+ti4CITI0+AczYo+5S+oylNtara23EAM1LhIxk1BkZoLwF8sBxzbZZCa5WeXzEhsKFIPI9V1ye59qp7OlFZF/Z/ceQADIhVhD94aMM75ayNnw/PL0YrIvXt/ND46xZb3smMTY1K4sSlXoUlciMjx6PDl+EGECec5fks20w+2V/I0PzRxcUMoopffKEAqFlOwIUZDEV7nWH1/4EyfIyyzKsqVlAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"walking skeleton\"\n        title=\"walking skeleton\"\n        src=\"/static/e772ae6d7ae6a4369beb1c330133321d/f058b/walking-skeleton-goos.png\"\n        srcset=\"/static/e772ae6d7ae6a4369beb1c330133321d/c26ae/walking-skeleton-goos.png 158w,\n/static/e772ae6d7ae6a4369beb1c330133321d/6bdcf/walking-skeleton-goos.png 315w,\n/static/e772ae6d7ae6a4369beb1c330133321d/f058b/walking-skeleton-goos.png 630w,\n/static/e772ae6d7ae6a4369beb1c330133321d/6af66/walking-skeleton-goos.png 640w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>A system is deployable when the acceptance tests all pass.</li>\n<li><strong>External quality</strong> is how well the system meets the needs of its customer and users. It’s usually part of the contract to build</li>\n<li><strong>Internal quality</strong> is how well the system meets the needs of its developers and administrators. The point of maintaining internal quality is to allow us to modify the system’s behaviour safely and predictably because it minimizes the risk that a change will force significant rework.</li>\n<li>Running end-to-end tests tells us about the external quality. Writing them tells us something about how well we understand the domain.</li>\n</ul>\n<h1>TDD as a design technique</h1>\n<ul>\n<li>An object-oriented system: A web of collaborating objects.</li>\n<li>Values vs objects\n<ul>\n<li>a value represents some fixed quantity or measurement, and it is immutable</li>\n<li>an object, on the other hand, is an identity that might change state over time. It models a computational process or a stateful behaviour of the system.</li>\n</ul>\n</li>\n<li>The communication between the objects can be seen through tests. So don’t try to model your system based on the entities (objects) alone, but on the communication between them.</li>\n<li>Objects follow common communication patterns. The domain model is in these communication patterns</li>\n<li>An object is an implementation of one or more roles:\n<ul>\n<li>roles a set of related responsibilities</li>\n<li>responsibilities is an obligation to perform a task or know information</li>\n<li>collaboration is an interaction of objects or roles.</li>\n</ul>\n</li>\n<li>An object communicates by messages: it receives messages from other objects. It reacts by sending messages to other objects as well, as perhaps, returning a value or exception to the original sender. An object has a method of handling every type of message that it understands. In most cases, it encapsulates some internal state that it uses to coordinate its communication with other objects.</li>\n<li>Make the intention of every test clear: distinguish between the tested functionality, the supporting infrastructure, and the object structure.</li>\n<li><strong>write unit tests for object behaviour rather than the object’s methods</strong></li>\n<li>something that is difficult to test is probably poorly designed</li>\n<li>The single responsibility principle\n<ul>\n<li>of the heuristic is that we should be able to describe what an object does without using any conjunction (“and,” “or”).</li>\n<li>interacting with the composite object should be more straightforward than interacting with the components that compose its</li>\n</ul>\n</li>\n<li><strong>The empty interface is sometimes used to mark a domain concept and show how it’s used in collaboration. Later, as we grow the code, we fill in the interface with methods to describe its behaviour.</strong></li>\n<li>Only mock types that you own:\n<ul>\n<li>don’t use mocks for third-party code since it is usually not changeable as you don’t have control over it.</li>\n<li>Use an adapter layer to implement interactions with third-party code. We test these adapters with focused integration tests to confirm our understanding of how the third-party API works.</li>\n<li>We must focus on the integration between our design and the external code. In integration, we have an abstraction to implement.</li>\n<li>we must check that we’re using the third-party API correctly and adjust our abstract to fit if we find that our assumptions are incorrect</li>\n<li>There are some exceptions where mocking third-party libraries can be helpful:\n<ul>\n<li>we might use mocks to simulate behaviour that is hard to trigger with the library</li>\n<li>we might use mocks to test a sequence of calls.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1>tell, don’t ask - law of Demeter</h1>\n<ul>\n<li>This style produces more flexible code because it’s easy to swap objects with the same role. The caller sees nothing of their internal structure or the rest of the system behind the role interface.</li>\n<li>we ask when\n<ul>\n<li>getting information from values and collections</li>\n<li>using a factory to create new objects</li>\n<li>searching or filtering</li>\n</ul>\n</li>\n<li><strong>we can specify how we expect the target object to communicate with its mock for a triggering event -> expectations</strong></li>\n<li>we can use the test to help us tease out the supporting roles our object needs, defined as Java interfaces, and fill in actual implementations as we develop the rest of the system -> interface discovery</li>\n<li>the essential structure of a test:\n<ul>\n<li>creating any required mock objects</li>\n<li>create any real objects</li>\n<li>specify how you expect the mock objects to be called by the target object</li>\n<li>call the triggering method on the target object</li>\n<li>assert that any resulting values are valid and that all the expected calls have been made.</li>\n</ul>\n</li>\n</ul>\n<h1>kick-staring the test-driven cycle</h1>\n<ul>\n<li>To run an initial end-to-end test that fails is already a lot of work. However, deploying and testing right from the start of a project forces the team to understand how their system fits into the world. it flushes out the “unknown.”</li>\n<li>Keep a drawing of the system’s structure on the whiteboard where it’s visible for the whole team and keep it in mind while coding! Then, make the smallest number of decisions you can to kick-start the TDD cycle. Then, we’ll learn and improve from honest feedback.</li>\n</ul>\n<p>test as a walking skeleton\na walking skeleton implements the thinnest possible slice of actual functionality that we can automatically build, deploy, and test end-to-end.\nIncluding the deployment step in the testing process is critical for 2 reasons\navoid the error-prone manual activity of deploying the system.\nFlush out the risks in operating the software (like 6 weeks and four signatures to set up a database, we want to know now, not 2 weeks before delivery.).\ncontext of the first test\nunderstand the problem -> broad-brush design (architecture) -> automate: build, deployment, end-to-end tests -> deployable system.\nwe have no guarantees that the decisions we’ve made about the design of our application are right\nOur ideal situation is where the team regularly releases a real production system. This allows the system’s stakeholders to respond to how well the system meets their needs, at the same time allowing us to judge its implementation\nwe use the automation of building and testing to give us feedback on the qualities of the system\nthe automated deployment helps us frequently release to real users, which gives us feedback\nthe great benefit is that we will be able to make changes in response to whatever we learn from feedback.\nExpose uncertainty early by testing our assumptions as early as possible.\nMaintaining the test-drive cycle\nstart each feature with an acceptance test\nwe write the acceptance using only terminology from the application’s domain\nthe precision of expression requirements in a form that can be automatically checked helps us uncover implicit assumptions\nstart testing with the simplest success case\nwe find it helpful to keep a notepad or index card by the keyboard to jot down failure cases, refactorings, and other technical tasks that need to be addressed\nwrite the test that you’d want to read\nwatch the test fail\nwhen we get the right failure, we check that the diagnostics are helpful.\nWe adjust the test code and rerun the tests until the error messages guide us to the problem with the code.\nError message checks our assumptions about the code we’ve working on\nemphasis on expressing our intentions is fundamental for developing reliable, maintainable systems.\nDevelop from the inputs to the outputs\nstart developing the feature by considering the events that trigger the new behaviour in the system.\nWe will need to write one or more objects to handle these events. We discover that these objects need supporting services from the rest of the system. In this way, we work our way through the system.\nunit test behaviour, not methods\none common mistake is thinking about testing methods. We do better when we focus on the object’s features under test should provide. It helps to choose test names that describe how the object behaves in the tested scenario.\nIt helps to name the test by describing the required behaviour in a specific scenario.\nListen to the tests\nwhen we find a complex feature to test, we ask ourselves how and why it is difficult to test.\nThe same structure that makes the code difficult to test now will make it difficult to change in the future.\nIf we find it hard to write the next failing test, we look again at the production design and then refactor it before moving on.\nThere’re lots of other books/articles on this topic, so at the least, there’s a section below dedicated to this topic.\nThe best we can get from the testing part of TDD is the confidence that we can change the code without breaking it. Fear kills progress. The trick is to make sure that the confidence is justified.\nDesign for Maintainability\nwe grow our systems a slice of functionality at a time\nwe use 2 principle heuristics to guide this structuring:\nseparation of concerns\nhigher levels of abstraction\nThat’s why most people order food from a menu in terms of dishes, rather than the detail of the recipes used to create them.\nIn its terminology, we write interfaces to describe its relationships with the outside world (Cockburn’s ports). Then we write bridges between the application core and each technical domain (Cockburn’s adapters). The bridges implement the interfaces defined by the application model and map between application-level and technical-level objects.\nThe code for the business domain is isolated from its dependencies on technical infrastructures, such as databases and user interfaces. We don’t want technical concepts to leak into the application model, so we write interfaces to describe their relationships with the outside world in its terminology\nwe have some second-level heuristics to help us think about how to find the facets in the behaviour where the interfaces should be:\nencapsulation ensures that the behaviour of an object can only be effected through its API\ninformation hiding conceals how an object implements its functionality behind the abstraction of its API\nwe follow standard practices to maintain encapsulation when coding:\ndefine immutable value types\navoid global variables and singletons\ncopy collections and mutable values when passing between objects, and so on.\ndon’t share a reference/pointer to a mutable object\ndon’t use global variables\ndon’t use singletons\nSingle responsibility principle: every object should have a single, clearly defined responsibility. We should describe what an object does without using any conjunctions.\nWe categorize an object’s peers into three types of relationship\ndependencies: the object cannot function without these services.\nNotifications: the object will notify interested peers whenever it changes state or performs a significant action. Messages are helpful because they decouple objects from each other. When listeners don’t know and shouldn’t care about how the event was caused, the sender doesn’t have to watch who listens to it. In short, fire and forget.\nAdjustments: Peers that adjust the object’s behaviour to the broader needs of the system.\nComposite simpler than the sum of its parts,\nthe API of a composite object should not be more complicated than of any of its components\nAs we grow the code, the composite more straightforward rules raise abstraction.\n“One domain vocabulary” rule: don’t use a term from another domain’s vocabulary unless you’re a bridging layer.\nHiding the correct information. Encapsulation is almost always a good thing to do, but sometimes information can be hidden in the wrong place.\nHaving an interface named thing and an implementation named ThingImpl is probably a sign of bad design. The interface should be described in general domain language and the implementation should have something specific about it to use in the name.\ndomain types are better than strings\nwhen we take the trouble to express the domain clearly, we often find that we have more options.\nListen to tests, test smells and patterns\nit’s another big topic that this book covered, so I have summarized it in different posts.\nTest Smells and Patterns Summary\ntechniques for introducing new objects\ndefine specific types to represent value concepts in the domain help:\nto find all the code relevant for a change without having to chase through the method calls\nto reduce the risk of confusion, using a more object-oriented instead of scattering related behaviour across the code.\n“Breaking out”:\nwhen an object becomes complex, that’s a sign that it’s implementing multiple concerns and that we can break out coherent units of behaviour into helper types\nOccasionally is better to treat this code as a spike: once we know what to do, just roll it back and re-implement it cleanly.\nBreak up an object if it becomes too large to test easily or if its test failures become challenging to interpret. Then unit tests the new parts separately.\n“Budding off”:\nwhen we want to mark a new domain concept in the code, we often introduce a placeholder type that wraps a single field. With each class that we add, we’re raising the level of abstraction of the code.\nTo avoid adding new behaviour that doesn’t belong to an object, we can create an interface to define the service that the object needs from the object’s point of view. Then, we write tests for the new behaviour as if the service already exists, using mock objects to help describe the relationship between the target object and its new collaborator. We think of this as an on-demand design.\nThe placeholder for a new object will be filled in with later implementation details. For example, when writing a test, we ask ourselves, “If this worked, who would know?”, if the correct answer to that question is not in the target object, it’s probably time to introduce a new collaborator.\n“Bundling up”:\ncreating a new object for a group of objects always used together. When the test for an object becomes too complicated to set up, […] consider bundling up some collaborating objects.\nThe new object hides the complexity in an abstraction.\nWe have to give the new entity a name that helps us understand the domain better.\nWe can scope the dependencies more clearly.\nwe can be more precise with our unit testing\nobject peer stereotypes\ndependencies\nservices that the object requires from its peers to perform its responsibilities.\nIt should not be possible to create the object without them.\nNotification\npeers that need to be kept up to date with the object’s activity. Notifications are “fire and forget.” Notifications are so helpful because they decouple objects from each other.\nAdjustments\npeers that adjust the object’s behaviour to the broader needs of the system.\nThis includes policy objects that make decisions on the object’s behalf.\nPartially creating an object and then finishing it off by setting properties is brittle because the programmer must remember to put all the dependencies.</p>\n<p>Notifications and adjustments can be passed to the constructor as a convenience. Alternatively, they can be initialized to safe defaults and overwritten later. For example, adjustments can be initialized to shared values and notifications to a null object or an empty collection. We then add methods to allow callers to change these default values and add or remove listeners.\nCommunication over classification\nUse interfaces to name roles played by objects and describe the messages they’ll accept. Keep interfaces as narrow as possible.\nWe can use interfaces to define the available messages between objects, but we also need to express their communication protocols.\nwe use TDD with mock objects as a technique to make these communication protocols visible, as a tool for discovering them during development and as a description when revisiting the code\nTDD with mock objects also encourages information hiding\nif similar interfaces represent different concepts, we can make a point of making them distinct. A decision to separate similar-looking interfaces is an excellent time to reconsider their naming\nAnother time to consider refactoring interfaces is when we start implementing them.\nProgramming by intention\ncompose objects to describe system behaviour\nTDD at the unit test level guides us to decompose our system into value types and loosely coupled computational objects\n. We can provide a description (the intention of the collaboration) of the expected calls for a test in a context by declaring the expectation of a mock object.\nThe advantage of this approach is that we have a flexible application structure from relatively little code. It’s particularly suitable where the code has to support many related scenarios.\nJust assigning and linking objects doesn’t help us understand the system’s assembling behaviour. Instead, the information we care about is typically buried in a morass of keywords, setters, punctuation, and the like.\nTo battle with this, we can organize the code in 2 layers\nimplementation layer: graph of objects, its behaviour is the combined result of how its objects respond to events.\nThe declarative layer\nis, in effect, a small domain-specific language embedded\nthe declarative layer that describes what the code will do. In contrast, the implementation layer defines how the code does it.\nThe different purposes of the 2 layers mean that we use a different coding style for each. For the implementation layer, we stick to the conventional object-oriented style guidelines. For the declarative layer, we’re more flexible\nmost of the time. Such a declarative layer merges from continual merciless refactoring. Taking care to notice when an area of code is not clear, we add or move structure until it is.\ndelegate to subordinate objects\nstarted writing the test we wanted to see and then filling in the supporting objects: start from a statement of the problem and see where it does.\nthe alternative is to write code directly in the tests and then refactor out any clusters of behaviours\nContext independence\nA system is easier to change if its objects are context-independent: each object has no built-in knowledge about the system.\nThe effect of the context-independence rule on a system of objects is to make their relationships explicit, defined separately from the objects themselves. This simplifies the objects and manages the relationships.\nDependency Injection\nDependency retention: We don’t worry about managing dependencies; we just inline and hard-code everything!\nDependency rejection, an excellent term (coined by Mark Seemann, above), in which we avoid having any dependencies in our core business logic. We do this by keeping all I/O and other impure code all the “edges” of our domain.\nDependency parameterization, in which we pass in all dependencies as parameters. This is commonly used in conjunction with partial application.\nDependency injection and the reader monad, in which we pass in dependencies after the rest of the code has already been constructed. This is typically done via constructor injection in OO-style code, and in FP-style principle, this corresponds to the Reader monad.\nDependency interpretation: We replace calls to dependencies with a data structure interpreted later. This approach is used in both OO (interpreter pattern) and in FP (e.g. free monads)\nNeed to elaborate more on these patterns\n<a href=\"https://fsharpforfunandprofit.com/posts/dependencies/\">https://fsharpforfunandprofit.com/posts/dependencies/</a>\n<a href=\"https://blog.thecodewhisperer.com/series#dependency-inversion-principle-dip\">https://blog.thecodewhisperer.com/series#dependency-inversion-principle-dip</a>\n<a href=\"https://blog.ploeh.dk/2017/01/27/from-dependency-injection-to-dependency-rejection/\">https://blog.ploeh.dk/2017/01/27/from-dependency-injection-to-dependency-rejection/</a>\nThe sample project - analysis\nthe business rules can be summarized with the following picture</p>\n<p>architecture the book came up with</p>\n<p>Quotes</p>\n<p>“The Golden Rule of TDD: Never write new functionality without a failing test.”</p>\n<p>“Object-oriented design focuses more on the communication between objects than on the objects themselves.”</p>\n<p>“Objects make their decisions based only on the information they hold internally or that which came with the triggering message.”</p>\n<p>“break up an object if it becomes too large to test easily, or if its test failures become difficult to interpret. Then unit tests the new parts separately.”</p>\n<p>“When writing a test, we ask ourselves, “If this worked, who would know?”, if the right answer to that question is not in the target object, it’s probably time to introduce a new collaborator.”</p>\n<p>“When the test for an object is too complicated to set up […] consider bundling up some of the collaborating objects.”</p>\n<p>“Nothing forces us to understand a process better than trying to automate it.”</p>\n<p>“Expect unexpected changes.”</p>\n<p>“Each object should have no built-in knowledge about the system in which it executes.”</p>\n<p>“The big idea is `messaging’ … the key in the making great, and growable systems is much more to design how its modules communicate rather than what their internal properties and behaviours should be”</p>\n<p>“Iteration Zero in most agile projects, there’s a first stage where the team setting u pits physical and technical environments. A common practice is to call this step iteration (the team still needs to time-box its activities) zero (before functional development starts in iteration one). One important task for iteration zero is to use the walking skeleton to test-drive the initial architecture.”</p>\n<p>“As the legends say, if we have something’s true name, we can control it.”</p>\n<p>“the string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.”</p>\n<p>“When we take the trouble to express the domain clearly, we often find that we have more options”</p>\n<p>“try to follow the four-step TDD cycle (fail, report (make the diagnostics clear), pass, refactor)”</p>\n<h1>References</h1>\n<p><a href=\"https://fsharpforfunandprofit.com/posts/dependencies/\">https://fsharpforfunandprofit.com/posts/dependencies/</a></p>\n<p><a href=\"https://blog.ploeh.dk/2017/01/27/from-dependency-injection-to-dependency-rejection/\">https://blog.ploeh.dk/2017/01/27/from-dependency-injection-to-dependency-rejection/</a></p>\n<p><a href=\"https://github.com/stefoxp/growing-object-oriented-software\">https://github.com/stefoxp/growing-object-oriented-software</a></p>\n<p><a href=\"http://hanalee.info/blog/growing-object-oriented-software-guided-by-tests.html\">http://hanalee.info/blog/growing-object-oriented-software-guided-by-tests.html</a></p>\n<p><a href=\"https://www.karam.io/blog/2021/book-summary-growing-object-oriented-software-guided-by-tests/\">https://www.karam.io/blog/2021/book-summary-growing-object-oriented-software-guided-by-tests/</a></p>\n<p><a href=\"https://nir-orman.medium.com/growing-object-oriented-software-guided-by-tests-chapter-6-a76e91e83f81\">https://nir-orman.medium.com/growing-object-oriented-software-guided-by-tests-chapter-6-a76e91e83f81</a></p>\n<p><a href=\"https://github.com/vobarian/growing-object-oriented-software\">https://github.com/vobarian/growing-object-oriented-software</a></p>\n<p><a href=\"https://enterprisecraftsmanship.com/posts/growing-object-oriented-software-guided-by-tests-without-mocks/\">https://enterprisecraftsmanship.com/posts/growing-object-oriented-software-guided-by-tests-without-mocks/</a></p>\n<p><a href=\"https://mateuscosta.me/2019-02-21-growing-object-oriented\">https://mateuscosta.me/2019-02-21-growing-object-oriented</a></p>\n<p><a href=\"https://conn.dev/books/growing-object-oriented-software.html\">https://conn.dev/books/growing-object-oriented-software.html</a></p>\n<p><a href=\"https://www.infoq.com/presentations/Stop-Refactoring/\">https://www.infoq.com/presentations/Stop-Refactoring/</a></p>\n<p><a href=\"http://jmock.org/oopsla2004.pdf\">http://jmock.org/oopsla2004.pdf</a></p>\n<p><a href=\"http://jmock.org/oopsla2006.pdf\">http://jmock.org/oopsla2006.pdf</a></p>\n<p><a href=\"https://www.jamesshore.com/v2/blog/2018/testing-without-mocks\">https://www.jamesshore.com/v2/blog/2018/testing-without-mocks</a></p>\n<p><a href=\"https://www.youtube.com/watch?v=mkQ-RvErLiU&#x26;ab_channel=TheLegacyofSoCraTes\">https://www.youtube.com/watch?v=mkQ-RvErLiU&#x26;ab_channel=TheLegacyofSoCraTes</a></p>\n<p><a href=\"https://martinfowler.com/articles/domain-oriented-observability.html\">https://martinfowler.com/articles/domain-oriented-observability.html</a></p>","frontmatter":{"title":"Listen to tests, test smells and patterns","date":"December 20, 2021","description":"listen to tests, test smells and patterns"}},"previous":{"fields":{"slug":"/listen-to-tests/"},"frontmatter":{"title":"Listen to tests, test smells and patterns"}},"next":null},"pageContext":{"id":"df65a369-42a7-51f0-80fa-ce1671f09e67","previousPostId":"8c6ee45b-c5fd-53b2-b876-3bb4eaea00dd","nextPostId":null}},
    "staticQueryHashes": ["2841359383","3257411868"]}